import os
import logging
from typing import Optional, Dict, Any, List

import aiohttp
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, ContextTypes, filters
from dotenv import load_dotenv


load_dotenv()

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(name)s: %(message)s')
logger = logging.getLogger(__name__)


class MentorMatchBot:
    def __init__(self) -> None:
        token = os.getenv('TELEGRAM_BOT_TOKEN')
        if not token:
            raise ValueError('TELEGRAM_BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω –≤ –æ–∫—Ä—É–∂–µ–Ω–∏–∏')
        self.server_url = os.getenv('SERVER_URL', 'http://localhost:8000')
        self.app = Application.builder().token(token).build()
        self._setup_handlers()

    def run(self) -> None:
        self.app.run_polling()

    def _setup_handlers(self) -> None:
        self.app.add_handler(CommandHandler('start', self.cmd_start2))
        self.app.add_handler(CommandHandler('help', self.cmd_help))

        # Lists (menu with add buttons)
        # Support pagination via optional suffix _<offset>
        self.app.add_handler(CallbackQueryHandler(self.cb_list_students_nav, pattern=r'^list_students(?:_\d+)?$'))
        self.app.add_handler(CallbackQueryHandler(self.cb_list_supervisors_nav, pattern=r'^list_supervisors(?:_\d+)?$'))
        self.app.add_handler(CallbackQueryHandler(self.cb_list_topics_nav, pattern=r'^list_topics(?:_\d+)?$'))
        self.app.add_handler(CallbackQueryHandler(self.cb_import_students, pattern=r'^import_students$'))
        # Add flows (callbacks)
        self.app.add_handler(CallbackQueryHandler(self.cb_add_student_info, pattern=r'^add_student$'))
        self.app.add_handler(CallbackQueryHandler(self.cb_add_supervisor_start, pattern=r'^add_supervisor$'))
        self.app.add_handler(CallbackQueryHandler(self.cb_add_topic_start, pattern=r'^add_topic$'))
        self.app.add_handler(CallbackQueryHandler(self.cb_add_topic_choose, pattern=r'^add_topic_role_(student|supervisor)$'))

        # Profiles
        self.app.add_handler(CallbackQueryHandler(self.cb_view_student, pattern=r'^student_\d+$'))
        self.app.add_handler(CallbackQueryHandler(self.cb_view_supervisor, pattern=r'^supervisor_\d+$'))
        self.app.add_handler(CallbackQueryHandler(self.cb_view_topic, pattern=r'^topic_\d+$'))

        # Matching actions
        self.app.add_handler(CallbackQueryHandler(self.cb_match_student, pattern=r'^match_student_\d+$'))
        self.app.add_handler(CallbackQueryHandler(self.cb_match_supervisor, pattern=r'^match_supervisor_\d+$'))

        # Back to main
        self.app.add_handler(CallbackQueryHandler(self.cb_back, pattern=r'^back_to_main$'))
        # Error handler
        self.app.add_error_handler(self.on_error)
        # Text input handler for simple add flows
        self.app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.on_text))

    # Compatibility wrapper used by handler registration
    async def cmd_start2(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        return await self.cmd_start(update, context)

    async def _api_get(self, path: str) -> Optional[Dict[str, Any]]:
        url = f'{self.server_url}{path}'
        try:
            async with aiohttp.ClientSession() as s:
                async with s.get(url, timeout=20) as r:
                    if r.status == 200:
                        return await r.json()
                    logger.error('GET %s -> %s', url, r.status)
        except Exception as e:
            logger.exception('GET %s failed: %s', url, e)
        return None

    async def _api_post(self, path: str, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        url = f'{self.server_url}{path}'
        try:
            async with aiohttp.ClientSession() as s:
                async with s.post(url, data=data, timeout=60) as r:
                    if r.status == 200:
                        return await r.json()
                    if r.status == 303:
                        return {'status': 'success'}
                    logger.error('POST %s -> %s', url, r.status)
        except Exception as e:
            logger.exception('POST %s failed: %s', url, e)
        return None

    # Commands
    async def cmd_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        kb = [
            [InlineKeyboardButton('üë®‚Äçüéì –°—Ç—É–¥–µ–Ω—Ç—ã', callback_data='list_students')],
            [InlineKeyboardButton('üßë‚Äçüè´ –ù–∞—É—á–Ω—ã–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏', callback_data='list_supervisors')],
            [InlineKeyboardButton('üìö –¢–µ–º—ã', callback_data='list_topics')],
        ]
        text = '–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª:'
        if update.message:
            await update.message.reply_text(text, reply_markup=InlineKeyboardMarkup(kb))
        elif update.callback_query:
            # –í–æ–∑–≤—Ä–∞—Ç –∏–∑ callback ‚Äî —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            await update.callback_query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(kb))

    async def cmd_help(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text('–†–∞–∑–¥–µ–ª—ã: –°—Ç—É–¥–µ–Ω—Ç—ã, –ù–∞—É—á–Ω—ã–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏, –¢–µ–º—ã. –í –ø—Ä–æ—Ñ–∏–ª–µ —Å—Ç—É–¥–µ–Ω—Ç–∞ ‚Äî –∫–Ω–æ–ø–∫–∞ –ü–æ–¥–æ–±—Ä–∞—Ç—å —Ç–µ–º—É. –í –ø—Ä–æ—Ñ–∏–ª–µ —Ç–µ–º—ã (–≥–¥–µ –Ω—É–∂–µ–Ω –Ω–∞—É—á–Ω—ã–π —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å) ‚Äî –ü–æ–¥–æ–±—Ä–∞—Ç—å –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è.')

    # Lists
    async def cb_list_students(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        data = await self._api_get('/api/students?limit=10') or []
        lines: List[str] = ['–°—Ç—É–¥–µ–Ω—Ç—ã:']
        kb: List[List[InlineKeyboardButton]] = []
        for s in data:
            lines.append(f"‚Ä¢ {s.get('full_name','‚Äì')} (id={s.get('id')})")
            kb.append([InlineKeyboardButton(s.get('full_name','‚Äì')[:30], callback_data=f"student_{s.get('id')}")])
        kb.append([InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')])
        await q.edit_message_text('\n'.join(lines), reply_markup=InlineKeyboardMarkup(kb))

    async def cb_list_supervisors(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        data = await self._api_get('/api/supervisors?limit=10') or []
        lines: List[str] = ['–ù–∞—É—á–Ω—ã–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏:']
        kb: List[List[InlineKeyboardButton]] = []
        for s in data:
            lines.append(f"‚Ä¢ {s.get('full_name','‚Äì')} (id={s.get('id')})")
            kb.append([InlineKeyboardButton(s.get('full_name','‚Äì')[:30], callback_data=f"supervisor_{s.get('id')}")])
        kb.append([InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')])
        await q.edit_message_text('\n'.join(lines), reply_markup=InlineKeyboardMarkup(kb))

    async def cb_list_topics(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        data = await self._api_get('/api/topics?limit=10') or []
        lines: List[str] = ['–¢–µ–º—ã:']
        kb: List[List[InlineKeyboardButton]] = []
        for t in data:
            title = (t.get('title') or '‚Äì')[:30]
            lines.append(f"‚Ä¢ {t.get('title','‚Äì')} (id={t.get('id')})")
            kb.append([InlineKeyboardButton(title, callback_data=f"topic_{t.get('id')}")])
        kb.append([InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')])
        await q.edit_message_text('\n'.join(lines), reply_markup=InlineKeyboardMarkup(kb))

    # Profiles
    async def cb_view_student(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        sid = int(q.data.split('_')[1])
        s = await self._api_get(f'/api/students/{sid}')
        if not s:
            await q.edit_message_text('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å —Å—Ç—É–¥–µ–Ω—Ç–∞')
            return
        text = (
            f"–°—Ç—É–¥–µ–Ω—Ç: {s.get('full_name','‚Äì')}\n"
            f"Username: {s.get('username') or '‚Äì'}\n"
            f"Email: {s.get('email') or '‚Äì'}\n"
            f"–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: {s.get('program') or '‚Äì'}\n"
            f"–ù–∞–≤—ã–∫–∏: {s.get('skills') or '‚Äì'}\n"
            f"–ò–Ω—Ç–µ—Ä–µ—Å—ã: {s.get('interests') or '‚Äì'}\n"
            f"CV: {(s.get('cv') or '‚Äì')[:200]}\n"
            f"ID: {s.get('id')}\n"
        )
        kb = [
            [InlineKeyboardButton('üß† –ü–æ–¥–æ–±—Ä–∞—Ç—å —Ç–µ–º—É', callback_data=f'match_student_{sid}')],
            [InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')],
        ]
        await q.edit_message_text(text, reply_markup=InlineKeyboardMarkup(kb))

    async def cb_view_supervisor(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        uid = int(q.data.split('_')[1])
        s = await self._api_get(f'/api/supervisors/{uid}')
        if not s:
            await q.edit_message_text('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è')
            return
        text = (
            f"–ù–∞—É—á–Ω—ã–π —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å: {s.get('full_name','‚Äì')}\n"
            f"Username: {s.get('username') or '‚Äì'}\n"
            f"Email: {s.get('email') or '‚Äì'}\n"
            f"–î–æ–ª–∂–Ω–æ—Å—Ç—å: {s.get('position') or '‚Äì'}\n"
            f"–°—Ç–µ–ø–µ–Ω—å: {s.get('degree') or '‚Äì'}\n"
            f"–í–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: {s.get('capacity') or '‚Äì'}\n"
            f"–ò–Ω—Ç–µ—Ä–µ—Å—ã: {s.get('interests') or '‚Äì'}\n"
            f"ID: {s.get('id')}\n"
        )
        kb = [[InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')]]
        await q.edit_message_text(text, reply_markup=InlineKeyboardMarkup(kb))

    async def cb_view_topic(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        tid = int(q.data.split('_')[1])
        t = await self._api_get(f'/api/topics/{tid}')
        if not t:
            await q.edit_message_text('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–µ–º—É')
            return
        role = t.get('seeking_role')
        text = (
            f"–¢–µ–º–∞: {t.get('title','‚Äì')}\n"
            f"–ê–≤—Ç–æ—Ä: {t.get('author','‚Äì')}\n"
            f"–ö–æ–≥–æ –∏—â–µ–º: {role}\n"
            f"–û–ø–∏—Å–∞–Ω–∏–µ: {(t.get('description') or '‚Äì')[:500]}\n"
            f"–û–∂–∏–¥–∞–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã: {(t.get('expected_outcomes') or '‚Äì')[:400]}\n"
            f"–¢—Ä–µ–±—É–µ–º—ã–µ –Ω–∞–≤—ã–∫–∏: {t.get('required_skills') or '‚Äì'}\n"
            f"ID: {t.get('id')}\n"
        )
        kb: List[List[InlineKeyboardButton]] = []
        if role == 'supervisor':
            kb.append([InlineKeyboardButton('üßë‚Äçüè´ –ü–æ–¥–æ–±—Ä–∞—Ç—å –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è', callback_data=f'match_supervisor_{tid}')])
        kb.append([InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')])
        await q.edit_message_text(text, reply_markup=InlineKeyboardMarkup(kb))

    # Matching
    async def cb_match_student(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        sid = int(q.data.split('_')[2])
        res = await self._api_post('/match-student', data={'student_user_id': sid})
        if not res or res.get('status') != 'ok':
            await q.edit_message_text('–û—à–∏–±–∫–∞ –ø–æ–¥–±–æ—Ä–∞ —Ç–µ–º—ã –¥–ª—è —Å—Ç—É–¥–µ–Ω—Ç–∞')
            return
        items = res.get('items', [])
        lines = [f'–¢–æ–ø‚Äë5 —Ç–µ–º –¥–ª—è —Å—Ç—É–¥–µ–Ω—Ç–∞ #{sid}:']
        for it in items:
            lines.append(f"#{it.get('rank')}. {it.get('title','‚Äì')} ‚Äî {it.get('reason','')}")
        kb = [[InlineKeyboardButton('‚¨ÖÔ∏è –ö —Å—Ç—É–¥–µ–Ω—Ç—É', callback_data=f'student_{sid}')]]
        await q.edit_message_text('\n'.join(lines), reply_markup=InlineKeyboardMarkup(kb))

    # Import students from Google Sheets
    async def cb_import_students(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        cfg = await self._api_get('/api/sheets-config')
        if not cfg or cfg.get('status') != 'configured':
            text = 'Google Sheets –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –£–∫–∞–∂–∏—Ç–µ SPREADSHEET_ID –∏ SERVICE_ACCOUNT_FILE –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.'
            kb = [[InlineKeyboardButton('üë®‚Äçüéì –ö —Å—Ç—É–¥–µ–Ω—Ç–∞–º', callback_data='list_students')]]
            await q.edit_message_text(text, reply_markup=InlineKeyboardMarkup(kb))
            return
        sid = cfg.get('spreadsheet_id')
        res = await self._api_post('/api/import-sheet', data={'spreadsheet_id': sid})
        if not res or res.get('status') != 'success':
            msg = (res or {}).get('message') or '–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞'
            text = f'‚ùå –ò–º–ø–æ—Ä—Ç –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω: {msg}'
        else:
            stats = res.get('stats', {})
            text = (
                '‚úÖ –ò–º–ø–æ—Ä—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω.\n'
                f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏: +{stats.get('inserted_users', 0)}\n"
                f"–ü—Ä–æ—Ñ–∏–ª–∏: +{stats.get('inserted_profiles', stats.get('upserted_profiles', 0))}\n"
                f"–¢–µ–º—ã: +{stats.get('inserted_topics', 0)}"
            )
        kb = [[InlineKeyboardButton('üë®‚Äçüéì –ö —Å—Ç—É–¥–µ–Ω—Ç–∞–º', callback_data='list_students')]]
        await q.edit_message_text(text, reply_markup=InlineKeyboardMarkup(kb))

    # List menus with add buttons (new handlers)
    async def cb_list_students_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        data = await self._api_get('/api/students?limit=10') or []
        lines: List[str] = ['–°—Ç—É–¥–µ–Ω—Ç—ã:']
        kb: List[List[InlineKeyboardButton]] = [
            [InlineKeyboardButton('‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å—Ç—É–¥–µ–Ω—Ç–∞', callback_data='add_student')],
            [InlineKeyboardButton('üì• –ò–º–ø–æ—Ä—Ç –∏–∑ Google-—Ç–∞–±–ª–∏—Ü', callback_data='import_students')],
        ]
        for s in data:
            lines.append(f"‚Ä¢ {s.get('full_name','‚Äì')} (id={s.get('id')})")
            kb.append([InlineKeyboardButton((s.get('full_name','‚Äì')[:30]), callback_data=f"student_{s.get('id')}")])
        kb.append([InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')])
        await q.edit_message_text('\n'.join(lines), reply_markup=InlineKeyboardMarkup(kb))

    async def cb_list_supervisors_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        data = await self._api_get('/api/supervisors?limit=10') or []
        lines: List[str] = ['–ù–∞—É—á–Ω—ã–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏:']
        kb: List[List[InlineKeyboardButton]] = [[InlineKeyboardButton('‚ûï –ù–∞—É—á–Ω—ã–π —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å', callback_data='add_supervisor')]]
        for s in data:
            lines.append(f"‚Ä¢ {s.get('full_name','‚Äì')} (id={s.get('id')})")
            kb.append([InlineKeyboardButton((s.get('full_name','‚Äì')[:30]), callback_data=f"supervisor_{s.get('id')}")])
        kb.append([InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')])
        await q.edit_message_text('\n'.join(lines), reply_markup=InlineKeyboardMarkup(kb))

    async def cb_list_topics_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        data = await self._api_get('/api/topics?limit=10') or []
        lines: List[str] = ['–¢–µ–º—ã:']
        kb: List[List[InlineKeyboardButton]] = [[InlineKeyboardButton('‚ûï –¢–µ–º–∞', callback_data='add_topic')]]
        for t in data:
            lines.append(f"‚Ä¢ {t.get('title','‚Äì')} (id={t.get('id')})")
            kb.append([InlineKeyboardButton(((t.get('title') or '‚Äì')[:30]), callback_data=f"topic_{t.get('id')}")])
        kb.append([InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')])
        await q.edit_message_text('\n'.join(lines), reply_markup=InlineKeyboardMarkup(kb))

    # List menus with pagination navigation
    async def cb_list_students_nav(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        offset = 0
        try:
            if '_' in (q.data or '') and q.data != 'list_students':
                offset = int(q.data.rsplit('_', 1)[1])
        except Exception:
            offset = 0
        limit = 10
        data = await self._api_get(f'/api/students?limit={limit}&offset={max(0, offset)}') or []
        lines: List[str] = ['–°—Ç—É–¥–µ–Ω—Ç—ã:']
        kb: List[List[InlineKeyboardButton]] = [
            [InlineKeyboardButton('‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å—Ç—É–¥–µ–Ω—Ç–∞', callback_data='add_student')],
            [InlineKeyboardButton('üì• –ò–º–ø–æ—Ä—Ç –∏–∑ Google-—Ç–∞–±–ª–∏—Ü', callback_data='import_students')],
        ]
        for s in data:
            lines.append(f"‚Ä¢ {s.get('full_name','‚Äì')} (id={s.get('id')})")
            kb.append([InlineKeyboardButton((s.get('full_name','‚Äì')[:30]), callback_data=f"student_{s.get('id')}")])
        nav: List[InlineKeyboardButton] = []
        if offset > 0:
            prev_off = max(0, offset - limit)
            nav.append(InlineKeyboardButton('‚óÄÔ∏è', callback_data=f'list_students_{prev_off}'))
        if len(data) == limit:
            next_off = offset + limit
            nav.append(InlineKeyboardButton('‚ñ∂Ô∏è', callback_data=f'list_students_{next_off}'))
        if nav:
            kb.append(nav)
        kb.append([InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')])
        await q.edit_message_text('\n'.join(lines), reply_markup=InlineKeyboardMarkup(kb))

    async def cb_list_supervisors_nav(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        offset = 0
        try:
            if '_' in (q.data or '') and q.data != 'list_supervisors':
                offset = int(q.data.rsplit('_', 1)[1])
        except Exception:
            offset = 0
        limit = 10
        data = await self._api_get(f'/api/supervisors?limit={limit}&offset={max(0, offset)}') or []
        lines: List[str] = ['–ù–∞—É—á–Ω—ã–µ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏:']
        kb: List[List[InlineKeyboardButton]] = [[InlineKeyboardButton('‚ûï –ù–∞—É—á–Ω—ã–π —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å', callback_data='add_supervisor')]]
        for s in data:
            lines.append(f"‚Ä¢ {s.get('full_name','‚Äì')} (id={s.get('id')})")
            kb.append([InlineKeyboardButton((s.get('full_name','‚Äì')[:30]), callback_data=f"supervisor_{s.get('id')}")])
        nav: List[InlineKeyboardButton] = []
        if offset > 0:
            prev_off = max(0, offset - limit)
            nav.append(InlineKeyboardButton('‚óÄÔ∏è', callback_data=f'list_supervisors_{prev_off}'))
        if len(data) == limit:
            next_off = offset + limit
            nav.append(InlineKeyboardButton('‚ñ∂Ô∏è', callback_data=f'list_supervisors_{next_off}'))
        if nav:
            kb.append(nav)
        kb.append([InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')])
        await q.edit_message_text('\n'.join(lines), reply_markup=InlineKeyboardMarkup(kb))

    async def cb_list_topics_nav(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        offset = 0
        try:
            if '_' in (q.data or '') and q.data != 'list_topics':
                offset = int(q.data.rsplit('_', 1)[1])
        except Exception:
            offset = 0
        limit = 10
        data = await self._api_get(f'/api/topics?limit={limit}&offset={max(0, offset)}') or []
        lines: List[str] = ['–¢–µ–º—ã:']
        kb: List[List[InlineKeyboardButton]] = [[InlineKeyboardButton('‚ûï –¢–µ–º–∞', callback_data='add_topic')]]
        for t in data:
            title = (t.get('title') or '‚Äì')[:30]
            lines.append(f"‚Ä¢ {t.get('title','‚Äì')} (id={t.get('id')})")
            kb.append([InlineKeyboardButton(title, callback_data=f"topic_{t.get('id')}")])
        nav: List[InlineKeyboardButton] = []
        if offset > 0:
            prev_off = max(0, offset - limit)
            nav.append(InlineKeyboardButton('‚óÄÔ∏è', callback_data=f'list_topics_{prev_off}'))
        if len(data) == limit:
            next_off = offset + limit
            nav.append(InlineKeyboardButton('‚ñ∂Ô∏è', callback_data=f'list_topics_{next_off}'))
        if nav:
            kb.append(nav)
        kb.append([InlineKeyboardButton('‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data='back_to_main')])
        await q.edit_message_text('\n'.join(lines), reply_markup=InlineKeyboardMarkup(kb))

    # Add flows (simple)
    async def cb_add_student_info(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        text = '–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—É–¥–µ–Ω—Ç–æ–≤ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ Google —Ñ–æ—Ä–º—É –∏ –∏–º–ø–æ—Ä—Ç –≤ –∞–¥–º–∏–Ω–∫–µ.'
        kb = [[InlineKeyboardButton('üë®‚Äçüéì –ö —Å—Ç—É–¥–µ–Ω—Ç–∞–º', callback_data='list_students')]]
        await q.edit_message_text(text, reply_markup=InlineKeyboardMarkup(kb))

    async def cb_add_supervisor_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        context.user_data['awaiting'] = 'add_supervisor_name'
        await q.edit_message_text('–í–≤–µ–¥–∏—Ç–µ –§–ò–û –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è —Å–æ–æ–±—â–µ–Ω–∏–µ–º. –î–ª—è –æ—Ç–º–µ–Ω—ã ‚Äî /start')

    async def cb_add_topic_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        kb = [
            [InlineKeyboardButton('üéì –ò—â—É —Å—Ç—É–¥–µ–Ω—Ç–∞', callback_data='add_topic_role_student')],
            [InlineKeyboardButton('üßë‚Äçüè´ –ò—â—É –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è', callback_data='add_topic_role_supervisor')],
            [InlineKeyboardButton('üìö –ö —Ç–µ–º–∞–º', callback_data='list_topics')],
        ]
        await q.edit_message_text('–í—ã–±–µ—Ä–∏—Ç–µ, –∫–æ–≥–æ –∏—â–µ—Ç —Ç–µ–º–∞:', reply_markup=InlineKeyboardMarkup(kb))

    async def cb_add_topic_choose(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        role = 'student' if q.data.endswith('_student') else 'supervisor'
        context.user_data['awaiting'] = 'add_topic_title'
        context.user_data['topic_role'] = role
        await q.edit_message_text('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–µ–º—ã —Å–æ–æ–±—â–µ–Ω–∏–µ–º. –î–ª—è –æ—Ç–º–µ–Ω—ã ‚Äî /start')

    async def on_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        awaiting = context.user_data.get('awaiting')
        if not awaiting:
            return
        text = (update.message.text or '').strip()
        if awaiting == 'add_supervisor_name':
            payload = {
                'full_name': text,
                'email': None,
                'username': getattr(update.effective_user, 'username', None) or None,
            }
            res = await self._api_post('/add-supervisor', data=payload)
            context.user_data['awaiting'] = None
            if res and res.get('status', 'success') in ('success', 'ok'):
                await update.message.reply_text('–ù–∞—É—á–Ω—ã–π —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω.', reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton('üßë‚Äçüè´ –ö –Ω–∞—É—á–Ω—ã–º —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è–º', callback_data='list_supervisors')]]))
            else:
                await update.message.reply_text('–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å –Ω–∞—É—á–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤–µ–±-–∞–¥–º–∏–Ω–∫—É.')
        elif awaiting == 'add_topic_title':
            role = context.user_data.get('topic_role') or 'student'
            payload = {
                'title': text,
                'seeking_role': role,
                'author_full_name': (getattr(update.effective_user, 'full_name', None) or 'Unknown Supervisor'),
            }
            res = await self._api_post('/add-topic', data=payload)
            context.user_data['awaiting'] = None
            context.user_data.pop('topic_role', None)
            if res and res.get('status', 'success') in ('success', 'ok'):
                await update.message.reply_text('–¢–µ–º–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞.', reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton('üìö –ö —Ç–µ–º–∞–º', callback_data='list_topics')]]))
            else:
                await update.message.reply_text('–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å —Ç–µ–º—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤–µ–±-–∞–¥–º–∏–Ω–∫—É.')

    async def cb_match_supervisor(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        tid = int(q.data.split('_')[2])
        res = await self._api_post('/match-topic', data={'topic_id': tid, 'target_role': 'supervisor'})
        if not res or res.get('status') not in ('ok', 'success'):
            await q.edit_message_text('–û—à–∏–±–∫–∞ –ø–æ–¥–±–æ—Ä–∞ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è –¥–ª—è —Ç–µ–º—ã')
            return
        items = res.get('items', [])
        lines = [f'–¢–æ–ø‚Äë5 —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ–π –¥–ª—è —Ç–µ–º—ã #{tid}:']
        for it in items:
            lines.append(f"#{it.get('rank')}. {it.get('full_name','‚Äì')} ‚Äî {it.get('reason','')}")
        kb = [[InlineKeyboardButton('‚¨ÖÔ∏è –ö —Ç–µ–º–µ', callback_data=f'topic_{tid}')]]
        await q.edit_message_text('\n'.join(lines), reply_markup=InlineKeyboardMarkup(kb))

    # Back
    async def cb_back(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q = update.callback_query; await q.answer()
        await self.cmd_start(update, context)

    # Global error handler (—á—Ç–æ–±—ã –Ω–µ —Å—ã–ø–∞–ª–∏—Å—å stacktrace –≤ –ª–æ–≥–∏ –±–µ–∑ –æ–±—Ä–∞–±–æ—Ç–∫–∏)
    async def on_error(self, update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        logger.exception('Bot error: %s', getattr(context, 'error', 'unknown'))


if __name__ == '__main__':
    bot = MentorMatchBot()
    bot.run()
